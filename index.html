<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Anchor Swing</title>
<script src="https://cdn.jsdelivr.net/npm/tone@15.1.22/dist/Tone.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.183.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/"
  }
}
</script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0A0A0F; overflow: hidden; }
canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  touch-action: none;
}
#ui {
  position: fixed;
  top: 16px; left: 0; right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px;
  font-family: 'Courier New', monospace;
  color: #F2A84B;
  font-size: 14px;
  letter-spacing: 2px;
  z-index: 10;
  pointer-events: none;
}
#lives { color: #00E5CC; letter-spacing: 4px; }
#crystalCount { color: #00E5CC; }
#startScreen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10,10,15,0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  cursor: pointer;
}
#startScreen h1 {
  font-family: 'Courier New', monospace;
  font-size: clamp(24px, 5vw, 48px);
  color: #F2A84B;
  letter-spacing: 6px;
  text-transform: uppercase;
  animation: swing-in 1.5s ease-out forwards;
  margin-bottom: 12px;
}
@keyframes swing-in {
  0% { transform: translateY(-80px) rotate(-12deg); opacity: 0; }
  60% { transform: translateY(0) rotate(6deg); opacity: 1; }
  80% { transform: rotate(-3deg); }
  100% { transform: rotate(0deg); opacity: 1; }
}
#startScreen p {
  font-family: 'Courier New', monospace;
  color: rgba(242,168,75,0.55);
  font-size: 13px;
  letter-spacing: 2px;
  margin-top: 6px;
}
#startScreen .sub {
  font-size: 11px;
  color: rgba(255,255,255,0.28);
  margin-top: 22px;
  letter-spacing: 2px;
  animation: blink 1.4s ease-in-out infinite;
}
@keyframes blink { 0%,100% { opacity: 0.3; } 50% { opacity: 1; } }
.hidden { display: none !important; }
#gameOver {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10,10,15,0.94);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  cursor: pointer;
}
#gameOver h2 {
  font-family: 'Courier New', monospace;
  font-size: 38px;
  color: #F2A84B;
  letter-spacing: 5px;
  margin-bottom: 14px;
}
#gameOver .score-display {
  font-family: 'Courier New', monospace;
  color: #00E5CC;
  font-size: 16px;
  letter-spacing: 3px;
  margin: 6px 0;
}
#gameOver .restart-hint {
  font-family: 'Courier New', monospace;
  color: rgba(255,255,255,0.28);
  font-size: 11px;
  margin-top: 22px;
  letter-spacing: 2px;
}
#levelBanner {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-family: 'Courier New', monospace;
  font-size: 24px;
  color: #00E5CC;
  letter-spacing: 5px;
  text-align: center;
  z-index: 50;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.4s;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="levelDisplay">LEVEL 1 — THE ENTRANCE</div>
  <div id="crystalCount">◆ 0/8</div>
  <div id="scoreDisplay">0</div>
  <div id="lives">♦♦♦</div>
</div>
<div id="levelBanner"></div>
<div id="startScreen">
  <h1>ANCHOR SWING</h1>
  <p>CLICK TO FIRE — SWING TO SURVIVE</p>
  <p class="sub">TAP ANYWHERE TO BEGIN</p>
</div>
<div id="gameOver" class="hidden">
  <h2>GAME OVER</h2>
  <div class="score-display" id="finalScore">SCORE: 0</div>
  <div class="score-display" id="highScoreDisplay">BEST: 0</div>
  <div class="restart-hint">TAP TO PLAY AGAIN</div>
</div>
<a href="https://github.com/nishivector/anchor-swing" target="_blank" style="position:fixed;bottom:16px;right:16px;color:rgba(255,255,255,0.35);font-size:12px;text-decoration:none;font-family:monospace;z-index:1000;">GitHub ↗</a>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ===== SCORE =====
const SCORE_KEY = 'anchor-swing-highscore';
function getHighScore() { return parseInt(localStorage.getItem(SCORE_KEY) || '0'); }
function saveHighScore(s) { if (s > getHighScore()) localStorage.setItem(SCORE_KEY, s); }

// ===== THREE.JS SETUP =====
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0A0A0F);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 18);
camera.lookAt(0, 0, 0);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.8, 0.4, 0.06
);
composer.addPass(bloomPass);

// ===== GAME CONSTANTS =====
// World units: 1 unit ≈ small distance
// Cave is a 2D side-scroller in world XY plane
const GRAVITY = 0.015;
const MAX_ROPE_LEN = 12;
const MIN_ROPE_LEN = 3;
const SPELUNKER_R = 0.25;
const CRYSTAL_R = 0.4;
const STALAGTITE_W = 0.5;

const LEVEL_CONFIGS = [
  { name: 'THE ENTRANCE',  crystals: 8,  stalactites: 4,  movingStalac: 0, falseAnchors: 0, caveW: 40, caveH: 20, water: false, time: 60 },
  { name: 'THE NARROWS',   crystals: 10, stalactites: 8,  movingStalac: 3, falseAnchors: 0, caveW: 35, caveH: 22, water: false, time: 50 },
  { name: 'CRYSTAL HALL',  crystals: 12, stalactites: 12, movingStalac: 4, falseAnchors: 0, caveW: 38, caveH: 25, water: false, time: 50 },
  { name: 'THE GAUNTLET',  crystals: 14, stalactites: 16, movingStalac: 6, falseAnchors: 4, caveW: 40, caveH: 28, water: false, time: 45 },
  { name: 'THE ABYSS',     crystals: 16, stalactites: 20, movingStalac: 8, falseAnchors: 8, caveW: 42, caveH: 32, water: true,  time: 70 },
];

// ===== GAME STATE =====
let gameState = 'start';
let score = 0;
let lives = 3;
let level = 0;
let crystalsCollected = 0;
let totalCrystals = 8;
let levelTimer = 60;
let levelBannerTimeout = null;

// Physics
let spelX = 0, spelY = 0;
let spelVX = 0, spelVY = 0;
let anchorX = 0, anchorY = 0;
let hasAnchor = false;
let ropeLen = 8;
let isSwinging = false;
let fallTimer = 0;
let gameObjects = { stalactites: [], crystals: [], anchorZones: [], exit: null };
let waterY = -999;
let waterRising = false;
let deathFlash = 0;
let particles = [];

// Camera
let camX = 0, camY = 0;

// ===== SCENE OBJECTS =====
const spelGroup = new THREE.Group();
scene.add(spelGroup);

// Spelunker body (silhouette)
const spelGeo = new THREE.CapsuleGeometry(SPELUNKER_R, 0.5, 4, 8);
const spelMat = new THREE.MeshBasicMaterial({ color: 0x0A0A0F });
const spelBody = new THREE.Mesh(spelGeo, spelMat);
spelBody.rotation.z = 0;
spelGroup.add(spelBody);

// Lantern glow
const lanternGeo = new THREE.SphereGeometry(0.2, 8, 8);
const lanternMat = new THREE.MeshBasicMaterial({ color: 0xF2A84B });
const lantern = new THREE.Mesh(lanternGeo, lanternMat);
lantern.position.set(0.3, -0.2, 0);
spelGroup.add(lantern);

// Outline for silhouette
const outlineGeo = new THREE.CapsuleGeometry(SPELUNKER_R + 0.08, 0.5, 4, 8);
const outlineMat = new THREE.MeshBasicMaterial({ color: 0xF2A84B, side: THREE.BackSide });
const spelOutline = new THREE.Mesh(outlineGeo, outlineMat);
spelGroup.add(spelOutline);

// Rope
const ropePoints = [new THREE.Vector3(0,0,0), new THREE.Vector3(0,5,0)];
const ropeGeo = new THREE.BufferGeometry().setFromPoints(ropePoints);
const ropeMat = new THREE.LineBasicMaterial({ color: 0xF2A84B, transparent: true, opacity: 0.8 });
const ropeLine = new THREE.Line(ropeGeo, ropeMat);
scene.add(ropeLine);

// Anchor point marker
const anchorGeo = new THREE.SphereGeometry(0.15, 8, 8);
const anchorMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
const anchorMesh = new THREE.Mesh(anchorGeo, anchorMat);
anchorMesh.visible = false;
scene.add(anchorMesh);

// Flash overlay
const flashGeo = new THREE.PlaneGeometry(100, 100);
const flashMat = new THREE.MeshBasicMaterial({ color: 0xFF2244, transparent: true, opacity: 0 });
const flashMesh = new THREE.Mesh(flashGeo, flashMat);
flashMesh.position.z = 8;
scene.add(flashMesh);

// Cave environment groups
const caveGroup = new THREE.Group();
scene.add(caveGroup);
const crystalGroup = new THREE.Group();
scene.add(crystalGroup);
const waterGroup = new THREE.Group();
scene.add(waterGroup);

// Vignette
const vigGeo = new THREE.PlaneGeometry(60, 60);
const vigMat = new THREE.ShaderMaterial({
  transparent: true,
  uniforms: { opacity: { value: 0.75 } },
  vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
  fragmentShader: `varying vec2 vUv; uniform float opacity;
    void main() {
      vec2 d = vUv * 2.0 - 1.0;
      float v = smoothstep(0.45, 1.0, length(d));
      gl_FragColor = vec4(0.0, 0.0, 0.0, v * opacity);
    }`
});
const vigMesh = new THREE.Mesh(vigGeo, vigMat);
vigMesh.position.z = 7;
scene.add(vigMesh);

// ===== AUDIO =====
let audioInit = false;
let droneOsc, crystalSynth, anchorSynth, ropeOsc, hitNoise, levelSynth;

async function initAudio() {
  if (audioInit) return;
  audioInit = true;
  await Tone.start();

  const caveReverb = new Tone.Reverb({ decay: 8, wet: 0.7 }).toDestination();
  droneOsc = new Tone.Oscillator({ type: 'sine', frequency: 55, volume: -22 }).connect(caveReverb).start();

  crystalSynth = new Tone.Synth({
    oscillator: { type: 'sine' },
    envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 1.5 },
    volume: -14
  }).connect(new Tone.Reverb({ decay: 2, wet: 0.5 }).toDestination());

  anchorSynth = new Tone.Synth({
    oscillator: { type: 'square' },
    envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.08 },
    volume: -10
  }).toDestination();

  hitNoise = new Tone.NoiseSynth({
    noise: { type: 'white' },
    envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 },
    volume: -10
  }).connect(new Tone.Reverb({ decay: 0.5, wet: 0.3 }).toDestination());

  levelSynth = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: 'sine' },
    envelope: { attack: 0.05, decay: 0.4, sustain: 0.2, release: 0.8 },
    volume: -14
  }).connect(new Tone.Reverb({ decay: 2, wet: 0.4 }).toDestination());
}

function sfxAnchorFire() { if (anchorSynth) anchorSynth.triggerAttackRelease(800, '32n'); }
function sfxCrystalCollect() { if (crystalSynth) crystalSynth.triggerAttackRelease(660, '4n'); }
function sfxHit() { if (hitNoise) hitNoise.triggerAttackRelease('8n'); }
function sfxLevelComplete() { if (levelSynth) levelSynth.triggerAttackRelease(['E3','G3','B3','E4'], '2n'); }

// ===== LEVEL GENERATION =====
function generateLevel(lvl) {
  // Clear previous level
  while (caveGroup.children.length) caveGroup.remove(caveGroup.children[0]);
  while (crystalGroup.children.length) crystalGroup.remove(crystalGroup.children[0]);
  while (waterGroup.children.length) waterGroup.remove(waterGroup.children[0]);
  particles = [];

  const cfg = LEVEL_CONFIGS[lvl];
  totalCrystals = cfg.crystals;
  crystalsCollected = 0;
  levelTimer = cfg.time;
  waterY = -cfg.caveH / 2 - 5;
  waterRising = cfg.water;

  gameObjects = { stalactites: [], crystals: [], anchorZones: [], exit: null, falseAnchors: [] };

  const caveW = cfg.caveW;
  const caveH = cfg.caveH;
  const caveLeft = -caveW / 2;
  const caveRight = caveW / 2;
  const caveTop = caveH / 2;
  const caveBottom = -caveH / 2;

  // Cave floor and ceiling (simple geometry)
  const ceilGeo = new THREE.PlaneGeometry(caveW + 4, 3);
  const ceilMat = new THREE.MeshBasicMaterial({ color: 0x0F0F1E });
  const ceilMesh = new THREE.Mesh(ceilGeo, ceilMat);
  ceilMesh.position.set(0, caveTop + 1.5, -1);
  caveGroup.add(ceilMesh);

  const floorGeo = new THREE.PlaneGeometry(caveW + 4, 3);
  const floorMesh = new THREE.Mesh(floorGeo, new THREE.MeshBasicMaterial({ color: 0x0F0F1E }));
  floorMesh.position.set(0, caveBottom - 1.5, -1);
  caveGroup.add(floorMesh);

  // Stalactites hanging from ceiling
  for (let i = 0; i < cfg.stalactites; i++) {
    const x = caveLeft + 3 + Math.random() * (caveW - 6);
    const h = 1.5 + Math.random() * 3;
    const w = 0.3 + Math.random() * 0.5;
    const y = caveTop;
    const moving = i < cfg.movingStalac;
    const speed = moving ? (0.5 + Math.random() * (0.5 + lvl * 0.25)) : 0;
    const dir = Math.random() > 0.5 ? 1 : -1;

    const geo = new THREE.ConeGeometry(w / 2, h, 6);
    const mat = new THREE.MeshBasicMaterial({ color: 0x1A1A2E });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y - h / 2, 0);
    mesh.rotation.z = Math.PI; // point downward
    caveGroup.add(mesh);

    gameObjects.stalactites.push({
      x, y: y - h, // tip Y (bottom of stalactite)
      w, h, speed, dir, moving,
      initX: x,
      mesh,
    });
  }

  // Crystals distributed across the cave
  for (let i = 0; i < cfg.crystals; i++) {
    const x = caveLeft + 2 + Math.random() * (caveW - 4);
    const y = caveBottom + 1 + Math.random() * (caveH - 2);
    const scale = 0.8 + Math.random() * 0.5;
    const pulsPhase = Math.random() * Math.PI * 2;

    const geo = new THREE.OctahedronGeometry(CRYSTAL_R * scale, 0);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00E5CC });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, 0);
    crystalGroup.add(mesh);

    // Glow sphere
    const glowGeo = new THREE.SphereGeometry(CRYSTAL_R * scale * 1.5, 8, 8);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0x00AA88, transparent: true, opacity: 0.25 });
    const glowMesh = new THREE.Mesh(glowGeo, glowMat);
    glowMesh.position.set(x, y, 0);
    crystalGroup.add(glowMesh);

    gameObjects.crystals.push({ x, y, scale, pulsPhase, collected: false, mesh, glowMesh });
  }

  // Anchor zones on ceiling (visible as faint blue dots)
  const numAnchorZones = 15 + lvl * 3;
  for (let i = 0; i < numAnchorZones; i++) {
    const x = caveLeft + 1 + Math.random() * (caveW - 2);
    const y = caveTop - 0.3;
    const isFalse = i < cfg.falseAnchors;

    const geo = new THREE.CircleGeometry(0.2, 8);
    const col = isFalse ? 0xF2A84B : 0x4455FF;
    const mat = new THREE.MeshBasicMaterial({ color: col, transparent: true, opacity: 0.3 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, 0.5);
    caveGroup.add(mesh);

    gameObjects.anchorZones.push({ x, y, isFalse, mesh });
    if (isFalse) gameObjects.falseAnchors.push({ x, y });
  }

  // Exit portal at right side
  const exitX = caveRight - 2;
  const exitY = 0;
  const exitGeo = new THREE.RingGeometry(0.6, 1.0, 16);
  const exitMat = new THREE.MeshBasicMaterial({ color: 0x00E5CC, side: THREE.DoubleSide });
  const exitMesh = new THREE.Mesh(exitGeo, exitMat);
  exitMesh.position.set(exitX, exitY, 0.5);
  caveGroup.add(exitMesh);

  const exitInnerGeo = new THREE.CircleGeometry(0.6, 16);
  const exitInnerMat = new THREE.MeshBasicMaterial({ color: 0x005544, transparent: true, opacity: 0.6 });
  const exitInnerMesh = new THREE.Mesh(exitInnerGeo, exitInnerMat);
  exitInnerMesh.position.set(exitX, exitY, 0.4);
  caveGroup.add(exitInnerMesh);

  gameObjects.exit = { x: exitX, y: exitY, r: 1.0, mesh: exitMesh };

  // Water surface (if applicable)
  if (cfg.water) {
    const waterGeo = new THREE.PlaneGeometry(caveW, 2);
    const waterMat = new THREE.MeshBasicMaterial({ color: 0x003388, transparent: true, opacity: 0.55 });
    const waterMesh = new THREE.Mesh(waterGeo, waterMat);
    waterMesh.position.set(0, waterY, 1);
    waterGroup.add(waterMesh);
    gameObjects.waterMesh = waterMesh;
  }

  // Spelunker start position — hang from ceiling with starting anchor
  spelX = caveLeft + 2;
  spelY = caveTop - 4;
  spelVX = 0;
  spelVY = 0;
  // Start with an anchor so spelunker doesn't fall immediately
  anchorX = caveLeft + 2;
  anchorY = caveTop;
  ropeLen = 4;
  hasAnchor = true;
  isSwinging = true;
  anchorMesh.visible = true;
  anchorMesh.position.set(anchorX, anchorY, 1);

  document.getElementById('levelDisplay').textContent = `LEVEL ${lvl + 1} — ${cfg.name}`;
  document.getElementById('crystalCount').textContent = `◆ 0/${totalCrystals}`;
  document.getElementById('lives').textContent = '♦'.repeat(lives);

  const banner = document.getElementById('levelBanner');
  banner.textContent = `LEVEL ${lvl + 1} — ${cfg.name.toUpperCase()}`;
  banner.style.opacity = '1';
  if (levelBannerTimeout) clearTimeout(levelBannerTimeout);
  levelBannerTimeout = setTimeout(() => { banner.style.opacity = '0'; }, 2000);
}

// ===== INPUT =====
let pointerWorldX = 0, pointerWorldY = 0;

function screenToWorld(ex, ey) {
  const rect = canvas.getBoundingClientRect();
  const nx = ((ex - rect.left) / rect.width) * 2 - 1;
  const ny = -((ey - rect.top) / rect.height) * 2 + 1;
  // Use camera projection
  const vector = new THREE.Vector3(nx, ny, 0.5);
  vector.unproject(camera);
  const dir = vector.sub(camera.position).normalize();
  const dist = -camera.position.z / dir.z;
  return {
    x: camera.position.x + dir.x * dist,
    y: camera.position.y + dir.y * dist,
  };
}

document.getElementById('startScreen').addEventListener('pointerdown', () => {
  gameState = 'playing';
  document.getElementById('startScreen').classList.add('hidden');
  initAudio().catch(() => {});
  generateLevel(0);
}, { once: true });

document.getElementById('gameOver').addEventListener('pointerdown', () => {
  document.getElementById('gameOver').classList.add('hidden');
  score = 0;
  lives = 3;
  level = 0;
  gameState = 'playing';
  generateLevel(0);
  document.getElementById('scoreDisplay').textContent = '0';
});

canvas.addEventListener('pointerdown', e => {
  if (gameState !== 'playing') return;
  const w = screenToWorld(e.clientX, e.clientY);
  fireAnchor(w.x, w.y);
  sfxAnchorFire();
});

canvas.addEventListener('pointerup', () => {
  if (gameState !== 'playing') return;
  releaseAnchor();
});

canvas.addEventListener('pointercancel', () => {
  if (gameState !== 'playing') return;
  releaseAnchor();
});

canvas.addEventListener('pointermove', e => {
  const w = screenToWorld(e.clientX, e.clientY);
  pointerWorldX = w.x;
  pointerWorldY = w.y;
});

function fireAnchor(wx, wy) {
  const cfg = LEVEL_CONFIGS[level];
  const caveTop = cfg.caveH / 2;

  // Clamp anchor to top of cave area (must be above spelunker)
  const ax = wx + camX;
  const ay = Math.min(caveTop, Math.max(spelY + 1, wy + camY));

  // Check if it's a false anchor
  let isFalse = false;
  for (const fa of (gameObjects.falseAnchors || [])) {
    if (Math.abs(ax - fa.x) < 1.5 && Math.abs(ay - fa.y) < 1.5) {
      isFalse = true;
      break;
    }
  }

  if (isFalse) {
    // Play crumble SFX and don't anchor
    if (hitNoise) hitNoise.triggerAttackRelease('16n');
    return;
  }

  anchorX = ax;
  anchorY = ay;
  hasAnchor = true;
  isSwinging = true;
  anchorMesh.visible = true;
  anchorMesh.position.set(anchorX, anchorY, 1);

  // Compute rope length
  const dx = spelX - anchorX;
  const dy = spelY - anchorY;
  ropeLen = Math.max(MIN_ROPE_LEN, Math.min(MAX_ROPE_LEN, Math.sqrt(dx*dx + dy*dy)));
}

function releaseAnchor() {
  hasAnchor = false;
  isSwinging = false;
  anchorMesh.visible = false;
  // Keep current velocity
}

// ===== PARTICLES =====
function spawnParticles3D(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 0.05 + Math.random() * 0.15;
    const geo = new THREE.SphereGeometry(0.08 + Math.random() * 0.12, 4, 4);
    const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, 0.5);
    scene.add(mesh);
    particles.push({ mesh, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 1.0 });
  }
}

// ===== PHYSICS UPDATE =====
function updatePhysics(dt) {
  if (!isSwinging || !hasAnchor) {
    // Free fall / projectile
    spelVY -= GRAVITY;
    spelX += spelVX;
    spelY += spelVY;
    fallTimer += dt;
  } else {
    // Pendulum constraint
    // Apply gravity to velocity
    spelVY -= GRAVITY;
    spelX += spelVX;
    spelY += spelVY;

    // Constrain to rope length
    const dx = spelX - anchorX;
    const dy = spelY - anchorY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > ropeLen) {
      const nx = dx / dist;
      const ny = dy / dist;
      spelX = anchorX + nx * ropeLen;
      spelY = anchorY + ny * ropeLen;
      // Remove radial velocity component
      const radialV = spelVX * nx + spelVY * ny;
      spelVX -= radialV * nx;
      spelVY -= radialV * ny;
      // Apply small damping
      spelVX *= 0.995;
      spelVY *= 0.995;
    }
    fallTimer = 0;
  }

  // Limit speed
  const speed = Math.sqrt(spelVX*spelVX + spelVY*spelVY);
  if (speed > 0.5) {
    spelVX = (spelVX / speed) * 0.5;
    spelVY = (spelVY / speed) * 0.5;
  }
}

// ===== COLLISION =====
function checkCollisions() {
  const cfg = LEVEL_CONFIGS[level];
  const caveLeft = -cfg.caveW / 2;
  const caveRight = cfg.caveW / 2;
  const caveTop = cfg.caveH / 2;
  const caveBottom = -cfg.caveH / 2;

  // Cave bounds — push back
  if (spelX < caveLeft + SPELUNKER_R) { spelX = caveLeft + SPELUNKER_R; spelVX = Math.abs(spelVX) * 0.3; }
  if (spelX > caveRight - SPELUNKER_R) { spelX = caveRight - SPELUNKER_R; spelVX = -Math.abs(spelVX) * 0.3; }
  if (spelY > caveTop - SPELUNKER_R) { spelY = caveTop - SPELUNKER_R; spelVY = -Math.abs(spelVY) * 0.3; hasAnchor = false; isSwinging = false; }

  // Cave floor — bounce or land (don't kill immediately, push back up)
  if (spelY < caveBottom + SPELUNKER_R) {
    spelY = caveBottom + SPELUNKER_R;
    spelVY = Math.abs(spelVY) * 0.2;
    spelVX *= 0.8;
  }

  // Fall off bottom (only kill if far below cave)
  if (spelY < caveBottom - 3) {
    killSpelunker();
    return;
  }

  // Stalactites
  for (const s of gameObjects.stalactites) {
    const dx = spelX - s.x;
    const dy = spelY - (s.y + s.h / 2);
    // Simple box check
    if (Math.abs(dx) < s.w / 2 + SPELUNKER_R && Math.abs(dy) < s.h / 2 + SPELUNKER_R * 0.5) {
      killSpelunker();
      return;
    }
  }

  // Water
  if (waterRising && spelY < waterY + SPELUNKER_R) {
    killSpelunker();
    return;
  }

  // Crystals
  for (const cr of gameObjects.crystals) {
    if (cr.collected) continue;
    const dx = spelX - cr.x;
    const dy = spelY - cr.y;
    if (Math.sqrt(dx*dx + dy*dy) < CRYSTAL_R * cr.scale * 1.5 + SPELUNKER_R) {
      cr.collected = true;
      cr.mesh.visible = false;
      cr.glowMesh.visible = false;
      crystalsCollected++;
      score += 200;
      sfxCrystalCollect();
      spawnParticles3D(cr.x, cr.y, 0x00E5CC, 12);
      document.getElementById('crystalCount').textContent = `◆ ${crystalsCollected}/${totalCrystals}`;
      document.getElementById('scoreDisplay').textContent = score;
    }
  }

  // Exit
  if (gameObjects.exit && crystalsCollected >= totalCrystals) {
    const ex = gameObjects.exit;
    const dx = spelX - ex.x;
    const dy = spelY - ex.y;
    if (Math.sqrt(dx*dx + dy*dy) < ex.r + SPELUNKER_R) {
      levelComplete();
    }
  }
}

function killSpelunker() {
  lives--;
  sfxHit();
  deathFlash = 1.0;
  flashMesh.material.opacity = 0.5;
  document.getElementById('lives').textContent = '♦'.repeat(Math.max(0, lives));
  spawnParticles3D(spelX, spelY, 0xFF2244, 15);

  if (lives <= 0) {
    gameState = 'gameover';
    saveHighScore(score);
    setTimeout(() => {
      document.getElementById('finalScore').textContent = 'SCORE: ' + score;
      document.getElementById('highScoreDisplay').textContent = 'BEST: ' + getHighScore();
      document.getElementById('gameOver').classList.remove('hidden');
    }, 800);
  } else {
    const cfg = LEVEL_CONFIGS[level];
    spelX = -cfg.caveW / 2 + 2;
    spelY = cfg.caveH / 2 - 4;
    spelVX = 0;
    spelVY = 0;
    // Respawn with anchor
    anchorX = spelX;
    anchorY = cfg.caveH / 2;
    ropeLen = 4;
    hasAnchor = true;
    isSwinging = true;
    anchorMesh.visible = true;
    anchorMesh.position.set(anchorX, anchorY, 1);
  }
}

function levelComplete() {
  score += 1000 + Math.floor(levelTimer) * 10;
  sfxLevelComplete();
  document.getElementById('scoreDisplay').textContent = score;
  spawnParticles3D(spelX, spelY, 0x00E5CC, 30);
  spawnParticles3D(gameObjects.exit.x, gameObjects.exit.y, 0xF2A84B, 20);

  if (level >= 4) {
    gameState = 'win';
    saveHighScore(score);
    setTimeout(() => {
      const go = document.getElementById('gameOver');
      go.querySelector('h2').textContent = 'CAVE CONQUERED';
      go.querySelector('h2').style.color = '#00E5CC';
      document.getElementById('finalScore').textContent = 'SCORE: ' + score;
      document.getElementById('highScoreDisplay').textContent = 'BEST: ' + getHighScore();
      go.classList.remove('hidden');
    }, 1200);
  } else {
    gameState = 'levelup';
    setTimeout(() => {
      level++;
      gameState = 'playing';
      generateLevel(level);
    }, 1800);
  }
}

// ===== UPDATE =====
let prevTime = performance.now();
let idleTime = 0;

function updateGame(dt, t) {
  if (gameState !== 'playing') return;

  // Timer
  levelTimer -= dt;
  if (levelTimer <= 0) { killSpelunker(); return; }

  // Physics
  updatePhysics(dt);

  // Water rising
  if (waterRising) {
    waterY += 0.008; // ~0.5 units/s at 60fps
    if (gameObjects.waterMesh) gameObjects.waterMesh.position.y = waterY;
  }

  // Move stalactites
  for (const s of gameObjects.stalactites) {
    if (!s.moving) continue;
    s.x += s.dir * s.speed * dt;
    const cfg = LEVEL_CONFIGS[level];
    if (s.x < -cfg.caveW / 2 + 1) { s.x = -cfg.caveW / 2 + 1; s.dir = 1; }
    if (s.x > cfg.caveW / 2 - 1) { s.x = cfg.caveW / 2 - 1; s.dir = -1; }
    s.mesh.position.x = s.x;
    s.y = cfg.caveH / 2 - s.h;
  }

  // Pulse crystals
  for (const cr of gameObjects.crystals) {
    if (cr.collected) continue;
    const pulse = 0.85 + 0.15 * Math.sin(t * 2 + cr.pulsPhase);
    cr.mesh.scale.setScalar(pulse);
    cr.glowMesh.scale.setScalar(pulse * 1.1);
    // Extra pulse if near spelunker
    const dx = spelX - cr.x, dy = spelY - cr.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 4) {
      const extra = 1 + 0.3 * (1 - dist / 4);
      cr.mesh.scale.setScalar(pulse * extra);
      cr.glowMesh.material.opacity = 0.25 + 0.4 * (1 - dist / 4);
    } else {
      cr.glowMesh.material.opacity = 0.25;
    }
  }

  // Pulse exit
  if (gameObjects.exit) {
    const exitPulse = 1 + 0.1 * Math.sin(t * 3);
    gameObjects.exit.mesh.scale.setScalar(exitPulse);
    // Only show fully if all crystals collected
    gameObjects.exit.mesh.material.opacity = crystalsCollected >= totalCrystals ? 1 : 0.35;
  }

  checkCollisions();

  // Camera follow
  camX += (spelX - camX) * 0.1;
  camY += (spelY - camY) * 0.08;
  camera.position.x = camX;
  camera.position.y = camY;

  // Rope visual
  if (hasAnchor) {
    const ropePos = ropeGeo.attributes.position;
    ropePos.setXYZ(0, spelX, spelY, 0.5);
    ropePos.setXYZ(1, anchorX, anchorY, 0.5);
    ropePos.needsUpdate = true;
    ropeLine.visible = true;
    anchorMesh.position.set(anchorX, anchorY, 1);
  } else {
    ropeLine.visible = false;
  }

  // Spelunker
  spelGroup.position.set(spelX, spelY, 1);
  // Lean based on velocity
  spelGroup.rotation.z = Math.max(-0.4, Math.min(0.4, -spelVX * 3));

  // Flash mesh follows camera
  flashMesh.position.set(camX, camY, 8);
  vigMesh.position.set(camX, camY, 7);

  // Death flash decay
  if (deathFlash > 0) {
    deathFlash -= dt * 2.5;
    flashMesh.material.opacity = Math.max(0, deathFlash * 0.5);
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.mesh.position.x += p.vx;
    p.mesh.position.y += p.vy;
    p.vy -= 0.003;
    p.life -= dt * 1.2;
    p.mesh.material.opacity = Math.max(0, p.life);
    if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
  }
}

// Idle animation for start screen
let idleSpelX = 0, idleSpelY = 0, idleAnchorX = 0, idleAnchorY = 4;
let idlePhase = 0;

function updateIdle(dt, t) {
  idlePhase += dt * 0.5;
  const pendulumAngle = Math.sin(idlePhase) * 1.2;
  idleSpelX = idleAnchorX + Math.sin(pendulumAngle) * 6;
  idleSpelY = idleAnchorY - Math.cos(pendulumAngle) * 6;

  spelGroup.position.set(idleSpelX, idleSpelY, 1);
  spelGroup.rotation.z = pendulumAngle;

  const ropePos = ropeGeo.attributes.position;
  ropePos.setXYZ(0, idleSpelX, idleSpelY, 0.5);
  ropePos.setXYZ(1, idleAnchorX, idleAnchorY, 0.5);
  ropePos.needsUpdate = true;
  ropeLine.visible = true;

  // Pulse idle crystals
  for (const cr of gameObjects.crystals || []) {
    if (cr.collected) continue;
    const pulse = 0.85 + 0.15 * Math.sin(t * 2 + cr.pulsPhase);
    cr.mesh.scale.setScalar(pulse);
    cr.glowMesh.scale.setScalar(pulse * 1.1);
  }
}

// ===== RENDER LOOP =====
function animate(now) {
  requestAnimationFrame(animate);
  const dt = Math.min((now - prevTime) / 1000, 0.05);
  prevTime = now;
  const t = now / 1000;

  if (gameState === 'start') {
    updateIdle(dt, t);
  } else if (gameState === 'playing') {
    updateGame(dt, t);
  } else if (gameState === 'levelup' || gameState === 'win') {
    // Just animate particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.mesh.position.x += p.vx;
      p.mesh.position.y += p.vy;
      p.vy -= 0.003;
      p.life -= dt * 1.2;
      p.mesh.material.opacity = Math.max(0, p.life);
      if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
    }
  }

  composer.render();
}

prevTime = performance.now();
animate(prevTime);

// ===== RESIZE =====
window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
