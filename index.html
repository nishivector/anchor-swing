<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Anchor Swing</title>
<script src="https://cdn.jsdelivr.net/npm/tone@15.1.22/build/Tone.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.183.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/"
  }
}
</script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0A0A0F; overflow: hidden; }
canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; touch-action: none; }
#ui {
  position: fixed; top: 16px; left: 0; right: 0;
  display: flex; justify-content: space-between; align-items: center;
  padding: 0 20px; font-family: 'Courier New', monospace;
  color: #F2A84B; font-size: 14px; letter-spacing: 2px;
  z-index: 10; pointer-events: none;
}
#lives { color: #00E5CC; }
#crystalCount { color: #00E5CC; }
#startScreen {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10,10,15,0.88);
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  z-index: 100; cursor: pointer;
}
#startScreen h1 {
  font-family: 'Courier New', monospace;
  font-size: clamp(24px, 5vw, 46px);
  color: #F2A84B; letter-spacing: 6px; text-transform: uppercase;
  animation: sway 2s ease-in-out infinite; margin-bottom: 12px;
}
@keyframes sway { 0%,100% { transform: rotate(-2deg); } 50% { transform: rotate(2deg); } }
#startScreen p { font-family: 'Courier New', monospace; color: rgba(242,168,75,0.55); font-size: 13px; letter-spacing: 2px; margin-top: 6px; }
#startScreen .sub { font-size: 11px; color: rgba(0,229,204,0.5); margin-top: 24px; letter-spacing: 2px; animation: blink 1.5s ease-in-out infinite; }
@keyframes blink { 0%,100% { opacity: 0.3; } 50% { opacity: 1; } }
.hidden { display: none !important; }
#gameOver {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10,10,15,0.93);
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  z-index: 100; cursor: pointer;
}
#goTitle { font-family: 'Courier New', monospace; font-size: 36px; color: #F2A84B; letter-spacing: 5px; margin-bottom: 14px; }
.sd { font-family: 'Courier New', monospace; color: #00E5CC; font-size: 16px; letter-spacing: 3px; margin: 6px 0; }
.rh { font-family: 'Courier New', monospace; color: rgba(255,255,255,0.28); font-size: 11px; margin-top: 22px; letter-spacing: 2px; }
#levelBanner {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  font-family: 'Courier New', monospace; font-size: 24px; color: #00E5CC;
  letter-spacing: 5px; z-index: 50; pointer-events: none;
  opacity: 0; transition: opacity 0.4s;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="levelDisplay">LEVEL 1</div>
  <div id="crystalCount">◆ 0/8</div>
  <div id="scoreDisplay">0</div>
  <div id="lives">♦♦♦</div>
</div>
<div id="levelBanner"></div>
<div id="startScreen">
  <h1>ANCHOR SWING</h1>
  <p>CLICK ABOVE TO FIRE ANCHOR — SWING TO CRYSTALS</p>
  <p>REACH THE EXIT PORTAL TO ADVANCE</p>
  <p class="sub">TAP ANYWHERE TO BEGIN</p>
</div>
<div id="gameOver" class="hidden">
  <div id="goTitle">CAVE CONQUERED</div>
  <div class="sd" id="finalScore">SCORE: 0</div>
  <div class="sd" id="highScoreDisplay">BEST: 0</div>
  <div class="rh">TAP TO PLAY AGAIN</div>
</div>
<a href="https://github.com/nishivector/anchor-swing" target="_blank"
   style="position:fixed;bottom:16px;right:16px;color:rgba(255,255,255,0.35);font-size:12px;text-decoration:none;font-family:monospace;z-index:1000;">GitHub ↗</a>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ===== HIGHSCORE =====
const SCORE_KEY = 'anchor-swing-highscore';
const getHighScore = () => parseInt(localStorage.getItem(SCORE_KEY) || '0');
const saveHighScore = s => { if (s > getHighScore()) localStorage.setItem(SCORE_KEY, s); };

// ===== RENDERER =====
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0A0A0F);

const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(
  -window.innerWidth / 2, window.innerWidth / 2,
  window.innerHeight / 2, -window.innerHeight / 2,
  0.1, 1000
);
camera.position.set(0, 0, 10);
camera.lookAt(0, 0, 0);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.4, 0.06
);
composer.addPass(bloomPass);

// ===== WORLD SCALE =====
// All game coordinates in pixels (1:1 with screen)
const W = window.innerWidth, H = window.innerHeight;
const CAVE_W = W * 2.5;   // wide scrolling cave
const CAVE_H = H * 0.85;
const CAVE_T = CAVE_H / 2;   // ceiling world Y
const CAVE_B = -CAVE_H / 2;  // floor world Y
const CAVE_L = -W / 2;       // left start
const CAVE_R = CAVE_L + CAVE_W;  // right end

// Physics (pixels)
const GRAVITY = 250;  // px/s² — gentle pendulum gravity
const MAX_SPEED = 600; // px/s
const SPELUNKER_R = 12;
const CRYSTAL_R = 16;
const STALAC_KILL_R = 20;

// ===== GAME STATE =====
let gameState = 'start';
let score = 0, lives = 3, level = 0, crystalsCollected = 0, totalCrystals = 8;
let levelTimer = 60;
let levelBannerTO = null;

// Physics state
let spelX = 0, spelY = 0;
let spelVX = 0, spelVY = 0;
let anchorX = 0, anchorY = 0;
let hasAnchor = false;
let ropeLen = 150;
let invincibleTimer = 0;
let deathFlash = 0;

// Camera scroll
let camX = 0;

// Game objects
let crystals = [];
let stalactites = [];
let exitPortal = { x: 0, y: 0, r: 40 };
let particles = [];

// ===== SCENE OBJECTS =====
const caveGroup = new THREE.Group();
scene.add(caveGroup);
const crystalGroup = new THREE.Group();
scene.add(crystalGroup);
const partGrp = new THREE.Group();
scene.add(partGrp);

// Spelunker (silhouette capsule)
const spelGrp = new THREE.Group();
scene.add(spelGrp);
const spelBody = new THREE.Mesh(
  new THREE.CircleGeometry(SPELUNKER_R, 12),
  new THREE.MeshBasicMaterial({ color: 0x111118 })
);
spelGrp.add(spelBody);
// Outline
const spelOutline = new THREE.Mesh(
  new THREE.CircleGeometry(SPELUNKER_R + 3, 12),
  new THREE.MeshBasicMaterial({ color: 0xF2A84B, side: THREE.BackSide })
);
spelGrp.add(spelOutline);
// Lantern
const lantern = new THREE.Mesh(
  new THREE.CircleGeometry(6, 8),
  new THREE.MeshBasicMaterial({ color: 0xFFCC66 })
);
lantern.position.set(10, -6, 0.1);
spelGrp.add(lantern);

// Rope line
const ropeGeo = new THREE.BufferGeometry().setFromPoints([
  new THREE.Vector3(0, 0, 0),
  new THREE.Vector3(0, -100, 0)
]);
const ropeLine = new THREE.Line(ropeGeo, new THREE.LineBasicMaterial({ color: 0xF2A84B, transparent: true, opacity: 0.75 }));
scene.add(ropeLine);

// Anchor point marker
const anchorMesh = new THREE.Mesh(
  new THREE.CircleGeometry(6, 8),
  new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
);
anchorMesh.visible = false;
scene.add(anchorMesh);

// Death flash
const flashMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(W * 3, H * 3),
  new THREE.MeshBasicMaterial({ color: 0xFF2244, transparent: true, opacity: 0 })
);
flashMesh.position.z = 8;
scene.add(flashMesh);

// Vignette
const vigMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(W * 3, H * 3),
  new THREE.ShaderMaterial({
    transparent: true,
    vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
    fragmentShader: `varying vec2 vUv; void main(){ vec2 d=vUv*2.0-1.0; float v=smoothstep(0.4,1.0,length(d)); gl_FragColor=vec4(0,0,0,v*0.8); }`
  })
);
vigMesh.position.z = 7;
scene.add(vigMesh);

// ===== AUDIO =====
let audioReady = false;
let anchorSynth, crystalSynth, hitSynth, levelSynth;

async function initAudio() {
  if (audioReady) return; audioReady = true;
  await Tone.start();
  const caveRev = new Tone.Reverb({ decay: 6, wet: 0.65 }).toDestination();
  const drone = new Tone.Oscillator({ type: 'sine', frequency: 55, volume: -24 }).connect(caveRev).start();
  anchorSynth = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.001, decay: 0.07, sustain: 0, release: 0.07 }, volume: -10 }).toDestination();
  crystalSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 1.2 }, volume: -13 }).connect(new Tone.Reverb({ decay: 2, wet: 0.5 }).toDestination());
  hitSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }, volume: -10 }).connect(new Tone.Reverb({ decay: 0.4, wet: 0.3 }).toDestination());
  levelSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.05, decay: 0.4, sustain: 0.2, release: 0.8 }, volume: -14 }).connect(new Tone.Reverb({ decay: 2, wet: 0.4 }).toDestination());
}

const sfxAnchor = () => { if (anchorSynth) anchorSynth.triggerAttackRelease(800, '32n'); };
const sfxCrystal = () => { if (crystalSynth) crystalSynth.triggerAttackRelease(660, '4n'); };
const sfxHit = () => { if (hitSynth) hitSynth.triggerAttackRelease('8n'); };
const sfxLevel = () => { if (levelSynth) levelSynth.triggerAttackRelease(['E3','G3','B3','E4'], '2n'); };

// ===== PARTICLES =====
function spawnParticles(x, y, color, n) {
  for (let i = 0; i < n; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = 30 + Math.random() * 120;
    const geo = new THREE.CircleGeometry(3 + Math.random() * 5, 6);
    const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x, y, 2);
    partGrp.add(m);
    particles.push({ mesh: m, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 1.0 });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.mesh.position.x += p.vx * dt;
    p.mesh.position.y += p.vy * dt;
    p.vy -= 200 * dt;
    p.life -= dt * 1.5;
    p.mesh.material.opacity = Math.max(0, p.life);
    if (p.life <= 0) { partGrp.remove(p.mesh); particles.splice(i, 1); }
  }
}

// ===== LEVEL SETUP =====
const LEVEL_CONFIGS = [
  { name: 'THE ENTRANCE',  crystals: 8,  stalactites: 5,  movingStalac: 0, time: 70 },
  { name: 'THE NARROWS',   crystals: 10, stalactites: 10, movingStalac: 3, time: 65 },
  { name: 'CRYSTAL HALL',  crystals: 12, stalactites: 15, movingStalac: 5, time: 60 },
  { name: 'THE GAUNTLET',  crystals: 14, stalactites: 20, movingStalac: 8, time: 55 },
  { name: 'THE ABYSS',     crystals: 16, stalactites: 25, movingStalac: 12, time: 70 },
];

function generateLevel(lvl) {
  level = lvl;
  const cfg = LEVEL_CONFIGS[lvl];
  totalCrystals = cfg.crystals;
  crystalsCollected = 0;
  levelTimer = cfg.time;
  crystals = [];
  stalactites = [];
  particles = [];

  // Clear scene objects
  while (caveGroup.children.length) caveGroup.remove(caveGroup.children[0]);
  while (crystalGroup.children.length) crystalGroup.remove(crystalGroup.children[0]);
  while (partGrp.children.length) partGrp.remove(partGrp.children[0]);

  // Cave ceiling bar
  const ceilMat = new THREE.MeshBasicMaterial({ color: 0x0D0D1F });
  caveGroup.add(Object.assign(new THREE.Mesh(new THREE.PlaneGeometry(CAVE_W + 200, 60), ceilMat), {
    position: new THREE.Vector3(CAVE_L + CAVE_W / 2, CAVE_T + 30, -0.5)
  }));
  // Cave floor bar
  caveGroup.add(Object.assign(new THREE.Mesh(new THREE.PlaneGeometry(CAVE_W + 200, 60), ceilMat), {
    position: new THREE.Vector3(CAVE_L + CAVE_W / 2, CAVE_B - 30, -0.5)
  }));

  // Crystals — placed across the cave width
  for (let i = 0; i < cfg.crystals; i++) {
    const cx = CAVE_L + (i + 1) * (CAVE_W / (cfg.crystals + 1));
    const cy = CAVE_B + 60 + Math.random() * (CAVE_H - 120);
    const phase = Math.random() * Math.PI * 2;

    // Crystal mesh (diamond shape)
    const geo = new THREE.OctahedronGeometry(CRYSTAL_R, 0);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00E5CC });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(cx, cy, 0);
    crystalGroup.add(mesh);

    // Glow
    const glowMat = new THREE.MeshBasicMaterial({ color: 0x00AA88, transparent: true, opacity: 0.28 });
    const glow = new THREE.Mesh(new THREE.CircleGeometry(CRYSTAL_R * 2, 12), glowMat);
    glow.position.set(cx, cy, -0.1);
    crystalGroup.add(glow);

    crystals.push({ x: cx, y: cy, phase, collected: false, mesh, glow });
  }

  // Stalactites hanging from ceiling — safe zone: first 300px from left is clear
  const SAFE_LEFT = CAVE_L + 300;
  for (let i = 0; i < cfg.stalactites; i++) {
    const sx = SAFE_LEFT + Math.random() * (CAVE_W - 360);
    const sh = 40 + Math.random() * 100;
    const sw = 15 + Math.random() * 20;
    const sy = CAVE_T; // top at ceiling
    const moving = i < cfg.movingStalac;
    const speed = moving ? (30 + Math.random() * (50 + lvl * 20)) : 0;
    const dir = Math.random() > 0.5 ? 1 : -1;

    // Stalactite as triangle/cone
    const geo = new THREE.ConeGeometry(sw / 2, sh, 5);
    const mat = new THREE.MeshBasicMaterial({ color: 0x1A1A2E });
    const mesh = new THREE.Mesh(geo, mat);
    // Cone default: tip at top. We want tip at bottom. Rotate 180°.
    mesh.rotation.z = Math.PI;
    // Position: center of cone = (sy - sh/2)
    mesh.position.set(sx, sy - sh / 2, 0);
    caveGroup.add(mesh);

    stalactites.push({
      x: sx, tipY: sy - sh, // tip world Y (bottom of stalactite)
      sw, sh, speed, dir, moving, mesh,
      minX: CAVE_L + 60, maxX: CAVE_R - 60,
    });
  }

  // Exit portal at right end of cave
  const exitX = CAVE_R - 80;
  const exitY = 0;
  const exitGeo = new THREE.RingGeometry(25, 40, 20);
  const exitMat = new THREE.MeshBasicMaterial({ color: 0x00E5CC, side: THREE.DoubleSide });
  const exitMesh = new THREE.Mesh(exitGeo, exitMat);
  exitMesh.position.set(exitX, exitY, 0.5);
  caveGroup.add(exitMesh);
  exitPortal = { x: exitX, y: exitY, r: 40, mesh: exitMesh };

  // Spelunker spawn: left side, vertically centered — well clear of ceiling
  spelX = CAVE_L + 80;
  spelY = 0;  // vertical center of cave
  spelVX = 0;
  spelVY = 0;
  // Start with anchor above
  anchorX = spelX;
  anchorY = CAVE_T;
  ropeLen = CAVE_T; // from center to ceiling
  hasAnchor = true;
  anchorMesh.visible = true;
  anchorMesh.position.set(anchorX, anchorY, 1);
  invincibleTimer = 4.0; // 4 seconds grace on level start

  camX = 0;

  document.getElementById('levelDisplay').textContent = `LEVEL ${lvl + 1} — ${cfg.name}`;
  document.getElementById('crystalCount').textContent = `◆ 0/${totalCrystals}`;
  document.getElementById('lives').textContent = '♦'.repeat(lives);
  document.getElementById('scoreDisplay').textContent = score;

  const banner = document.getElementById('levelBanner');
  banner.textContent = cfg.name;
  banner.style.opacity = '1';
  if (levelBannerTO) clearTimeout(levelBannerTO);
  levelBannerTO = setTimeout(() => { banner.style.opacity = '0'; }, 2000);
}

// ===== INPUT =====
function screenToWorld(ex, ey) {
  const rect = canvas.getBoundingClientRect();
  const sx = (ex - rect.left) / rect.width * W - W / 2;
  const sy = -((ey - rect.top) / rect.height * H - H / 2);
  // Apply camera scroll
  return { x: sx + camX, y: sy };
}

function fireAnchor(wx, wy) {
  // Anchor must be above spelunker
  const ay = Math.min(CAVE_T, Math.max(spelY + 20, wy));
  const ax = Math.max(CAVE_L, Math.min(CAVE_R, wx));
  anchorX = ax;
  anchorY = ay;
  const dx = spelX - ax, dy = spelY - ay;
  ropeLen = Math.max(60, Math.min(H * 0.6, Math.sqrt(dx * dx + dy * dy)));
  hasAnchor = true;
  anchorMesh.visible = true;
  anchorMesh.position.set(anchorX - camX, anchorY, 1);
  sfxAnchor();
}

function releaseAnchor() {
  hasAnchor = false;
  anchorMesh.visible = false;
}

document.getElementById('startScreen').addEventListener('pointerdown', () => {
  gameState = 'playing';
  document.getElementById('startScreen').classList.add('hidden');
  initAudio().catch(() => {});
  generateLevel(0);
}, { once: true });

document.getElementById('gameOver').addEventListener('pointerdown', () => {
  document.getElementById('gameOver').classList.add('hidden');
  score = 0; lives = 3;
  gameState = 'playing';
  generateLevel(0);
});

canvas.addEventListener('pointerdown', e => {
  if (gameState !== 'playing') return;
  const w = screenToWorld(e.clientX, e.clientY);
  fireAnchor(w.x, w.y);
});

canvas.addEventListener('pointerup', () => {
  if (gameState !== 'playing') return;
  releaseAnchor();
});

canvas.addEventListener('pointercancel', () => {
  if (gameState !== 'playing') return;
  releaseAnchor();
});

// ===== DEATH =====
function killSpelunker() {
  if (invincibleTimer > 0) return; // grace period
  lives--;
  sfxHit();
  deathFlash = 1.0;
  flashMesh.material.opacity = 0.5;
  document.getElementById('lives').textContent = '♦'.repeat(Math.max(0, lives));
  spawnParticles(spelX - camX, spelY, 0xFF2244, 15);

  if (lives <= 0) {
    gameState = 'gameover';
    saveHighScore(score);
    setTimeout(() => {
      document.getElementById('goTitle').textContent = 'GAME OVER';
      document.getElementById('goTitle').style.color = '#FF4466';
      document.getElementById('finalScore').textContent = 'SCORE: ' + score;
      document.getElementById('highScoreDisplay').textContent = 'BEST: ' + getHighScore();
      document.getElementById('gameOver').classList.remove('hidden');
    }, 800);
  } else {
    // Respawn at start of current level
    spelX = CAVE_L + 80;
    spelY = 0;
    spelVX = 0;
    spelVY = 0;
    anchorX = spelX;
    anchorY = CAVE_T;
    ropeLen = CAVE_T;
    hasAnchor = true;
    anchorMesh.visible = true;
    anchorMesh.position.set(anchorX - camX, anchorY, 1);
    invincibleTimer = 4.0;
    camX = 0;
    gameState = 'playing';
  }
}

// ===== LEVEL COMPLETE =====
function levelComplete() {
  score += 1000 + Math.floor(levelTimer) * 10;
  sfxLevel();
  document.getElementById('scoreDisplay').textContent = score;
  spawnParticles(exitPortal.x - camX, exitPortal.y, 0x00E5CC, 30);

  if (level >= 4) {
    gameState = 'win';
    saveHighScore(score);
    setTimeout(() => {
      document.getElementById('goTitle').textContent = 'CAVE CONQUERED!';
      document.getElementById('goTitle').style.color = '#00E5CC';
      document.getElementById('finalScore').textContent = 'SCORE: ' + score;
      document.getElementById('highScoreDisplay').textContent = 'BEST: ' + getHighScore();
      document.getElementById('gameOver').classList.remove('hidden');
    }, 1200);
  } else {
    gameState = 'levelup';
    setTimeout(() => {
      gameState = 'playing';
      generateLevel(level + 1);
    }, 1800);
  }
}

// ===== PHYSICS UPDATE =====
function updatePhysics(dt) {
  if (!hasAnchor) {
    // Free fall
    spelVY -= GRAVITY * dt;
  } else {
    // Pendulum: apply gravity, then constrain to rope
    spelVY -= GRAVITY * dt;
    spelX += spelVX * dt;
    spelY += spelVY * dt;

    // Constrain to rope
    const dx = spelX - anchorX;
    const dy = spelY - anchorY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > ropeLen) {
      const nx = dx / dist, ny = dy / dist;
      spelX = anchorX + nx * ropeLen;
      spelY = anchorY + ny * ropeLen;
      const radV = spelVX * nx + spelVY * ny;
      spelVX -= radV * nx * 1.0;
      spelVY -= radV * ny * 1.0;
      // Light air resistance
      spelVX *= 0.998;
      spelVY *= 0.998;
    }
    return; // early return — position already updated above
  }

  spelX += spelVX * dt;
  spelY += spelVY * dt;

  // Speed cap
  const spd = Math.sqrt(spelVX * spelVX + spelVY * spelVY);
  if (spd > MAX_SPEED) { spelVX *= MAX_SPEED / spd; spelVY *= MAX_SPEED / spd; }
}

// ===== MAIN GAME UPDATE =====
function updateGame(dt, t) {
  if (gameState !== 'playing') return;

  updatePhysics(dt);

  // Invincibility timer
  if (invincibleTimer > 0) invincibleTimer -= dt;

  // Timer
  levelTimer -= dt;
  if (levelTimer <= 0 && invincibleTimer <= 0) { killSpelunker(); return; }

  // Cave bounds — floor bounce, ceiling bounce
  if (spelY < CAVE_B + SPELUNKER_R) {
    spelY = CAVE_B + SPELUNKER_R;
    spelVY = Math.abs(spelVY) * 0.25;
    spelVX *= 0.7;
  }
  if (spelY > CAVE_T - SPELUNKER_R) {
    spelY = CAVE_T - SPELUNKER_R;
    spelVY = -Math.abs(spelVY) * 0.25;
  }

  // Left/right wall bounce
  if (spelX < CAVE_L + SPELUNKER_R) {
    spelX = CAVE_L + SPELUNKER_R;
    spelVX = Math.abs(spelVX) * 0.3;
  }
  if (spelX > CAVE_R - SPELUNKER_R) {
    spelX = CAVE_R - SPELUNKER_R;
    spelVX = -Math.abs(spelVX) * 0.3;
  }

  // Camera smooth follow (X only)
  const targetCamX = spelX;
  camX += (targetCamX - camX) * 0.08;
  const viewX = spelX - camX;

  // Update spelunker mesh
  spelGrp.position.set(viewX, spelY, 1);
  spelGrp.rotation.z = Math.max(-0.4, Math.min(0.4, spelVX * -0.002));

  // Update rope
  if (hasAnchor) {
    const rPos = ropeGeo.attributes.position;
    rPos.setXYZ(0, viewX, spelY, 0.5);
    rPos.setXYZ(1, anchorX - camX, anchorY, 0.5);
    rPos.needsUpdate = true;
    ropeLine.visible = true;
    anchorMesh.position.set(anchorX - camX, anchorY, 1);
    anchorMesh.visible = true;
  } else {
    ropeLine.visible = false;
    anchorMesh.visible = false;
  }

  // Scroll cave group
  caveGroup.position.x = -camX;
  crystalGroup.position.x = -camX;

  // Flash/vignette follow
  flashMesh.position.set(viewX, spelY, 8);
  vigMesh.position.set(viewX, spelY, 7);

  // Stalactite collisions (only when not invincible)
  if (invincibleTimer <= 0) {
    for (const s of stalactites) {
      if (s.moving) {
        s.x += s.dir * s.speed * dt;
        if (s.x < s.minX) { s.x = s.minX; s.dir = 1; }
        if (s.x > s.maxX) { s.x = s.maxX; s.dir = -1; }
        s.mesh.position.x = s.x;
        s.tipY = CAVE_T - s.sh;
      }
      // Collision: spelunker vs stalactite tip zone
      const dx = spelX - s.x;
      const dy = spelY - s.tipY;
      if (Math.abs(dx) < s.sw / 2 + SPELUNKER_R && dy > -10 && dy < SPELUNKER_R + 10) {
        killSpelunker();
        return;
      }
    }
  }

  // Crystal collection
  for (const cr of crystals) {
    if (cr.collected) continue;
    const dx = spelX - cr.x, dy = spelY - cr.y;
    if (Math.sqrt(dx * dx + dy * dy) < CRYSTAL_R + SPELUNKER_R + 8) {
      cr.collected = true;
      cr.mesh.visible = false;
      cr.glow.visible = false;
      crystalsCollected++;
      score += 200;
      sfxCrystal();
      spawnParticles(cr.x - camX, cr.y, 0x00E5CC, 12);
      document.getElementById('crystalCount').textContent = `◆ ${crystalsCollected}/${totalCrystals}`;
      document.getElementById('scoreDisplay').textContent = score;
    }
    // Pulse
    const pulse = 0.85 + 0.15 * Math.sin(t * 2.5 + cr.phase);
    cr.mesh.scale.setScalar(pulse);
    cr.glow.scale.setScalar(pulse * 1.2);
  }

  // Exit check
  if (crystalsCollected >= totalCrystals) {
    const dx = spelX - exitPortal.x, dy = spelY - exitPortal.y;
    if (Math.sqrt(dx * dx + dy * dy) < exitPortal.r + SPELUNKER_R) {
      levelComplete();
      return;
    }
    exitPortal.mesh.scale.setScalar(1 + 0.1 * Math.sin(t * 3));
  }

  // Death flash decay
  if (deathFlash > 0) {
    deathFlash -= dt * 2.5;
    flashMesh.material.opacity = Math.max(0, deathFlash * 0.5);
  }

  updateParticles(dt);
}

// ===== IDLE ANIMATION =====
let idleAngle = 0;
const IDLE_ANCHOR_X = 0, IDLE_ANCHOR_Y = H * 0.25;
const IDLE_ROPE = H * 0.3;

function updateIdle(dt, t) {
  idleAngle = Math.sin(t * 0.8) * 0.8;
  const ix = IDLE_ANCHOR_X + Math.sin(idleAngle) * IDLE_ROPE;
  const iy = IDLE_ANCHOR_Y - Math.cos(idleAngle) * IDLE_ROPE;
  spelGrp.position.set(ix, iy, 1);
  spelGrp.rotation.z = idleAngle;

  const rPos = ropeGeo.attributes.position;
  rPos.setXYZ(0, ix, iy, 0.5);
  rPos.setXYZ(1, IDLE_ANCHOR_X, IDLE_ANCHOR_Y, 0.5);
  rPos.needsUpdate = true;
  ropeLine.visible = true;
  anchorMesh.position.set(IDLE_ANCHOR_X, IDLE_ANCHOR_Y, 1);
  anchorMesh.visible = true;

  updateParticles(dt);
}

// ===== RENDER LOOP =====
let prevTime = performance.now();

function animate(now) {
  requestAnimationFrame(animate);
  const dt = Math.min((now - prevTime) / 1000, 0.05);
  prevTime = now;
  const t = now / 1000;

  if (gameState === 'start') {
    updateIdle(dt, t);
  } else if (gameState === 'playing') {
    updateGame(dt, t);
  } else {
    updateParticles(dt);
    if (deathFlash > 0) {
      deathFlash -= dt * 2.5;
      flashMesh.material.opacity = Math.max(0, deathFlash * 0.5);
    }
  }

  composer.render();
}

prevTime = performance.now();
animate(prevTime);

window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
